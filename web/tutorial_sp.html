<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.6: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5951 2009-05-18 18:03:10Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left{
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: left }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<div class="section" id="lalita">
<h1>Lalita</h1>
<div class="section" id="quien-es-lalita">
<h2>¿Quién es Lalita?</h2>
<p>Lalita es un bot de IRC al que de forma sencilla se le pueden agregar plugins
con nuevas funcionalidades.  El objetivo es que sea muy fácil implementar lo
que uno necesite en un bot.</p>
<p>En otras palabras, Lalita es un framework que nos permite armar nuestro bot
IRC a medida, de manera sencilla y rápida.  Como si eso fuera poco, además
tenemos algunos plugins que vienen incluidos (ver abajo).</p>
</div>
<div class="section" id="que-es-un-bot-irc">
<h2>¿Qué es un bot IRC?</h2>
<p>Un bot IRC es un programa que entra en algún canal en algún servidor de
<a class="reference external" href="http://es.wikipedia.org/wiki/Internet_Relay_Chat">IRC</a> (o a muchos canales en un servidor, o a muchos servidores, etc.), y
se comporta como un miembro más del canal.</p>
<p>La idea de un bot IRC no es hacerse pasar por un ser humano conectado (la
mayoría de las veces), sino prestar determinados servicios a los usuarios
del canal (la palabra 'bot' es un diminutivo de 'robot').</p>
<p>La prestación de estos servicios involucra que el bot reciba de alguna manera
lo que la gente dice, y que les conteste.  A lo largo de los siguientes
ejemplos veremos distintas formas de hacer esto.</p>
</div>
</div>
<div class="section" id="un-ejemplo-basico">
<h1>Un ejemplo básico</h1>
<p>En esta sección armaremos un plugin sencillo que suma los números que dice
una persona al hablarle al bot.</p>
<p>El siguiente es el código en cuestión:</p>
<pre class="literal-block">
# -*- coding: utf8 -*-

from lalita import Plugin

class Sum(Plugin):
    &quot;&quot;&quot;Ejemplo que suma los nros pasados.&quot;&quot;&quot;

    def init(self, config):
        self.register(self.events.TALKED_TO_ME, self.action)

    def action(self, user, channel, msg):
        u&quot;Suma los números recibidos.&quot;
        result = sum(int(x) for x in msg.split())
        self.say(channel, u&quot;%s, la suma es %d&quot;, user, result)
</pre>
<p>Vemos que el plugin se implementa como una clase de Python que hereda de
Plugin (el cual es importado arriba de todo).  El heredar de esta clase nos
permite acceder a toda la funcionalidad básica necesaria para armar nuestro
plugin, como veremos en los próximos párrafos.</p>
<p>Esta clase será instanciada por el sistema para cada canal o servidor, y en
el momento de instanciar se le pasará una configuración (en este caso no
la usamos, ver abajo más info sobre esto).  El momento de la instanciación
es el adecuado para que el plugin se registre en los eventos que desea
escuchar; en este ejemplo sólo nos registramos a un sólo evento,
<tt class="docutils literal">TALKED_TO_ME</tt>, y le decimos que en ese caso nos ejecute un determinado
método.</p>
<p>Analicemos esa linea con más detalle:</p>
<pre class="literal-block">
self.register(self.events.TALKED_TO_ME, self.action)
</pre>
<p>El método <tt class="docutils literal">self.register</tt> es el que usamos para registrarnos en un
evento.  Al mismo le pasaremos al menos dos parámetros (ver más abajo para
una descripción detallada de todos los casos), el evento y un método propio.</p>
<p>En este caso el evento es <tt class="docutils literal">TALKED_TO_ME</tt>, que sucede cuando en el canal
se le habla al bot, y se accede a través del atributo <tt class="docutils literal">self.events</tt>.  Y
el método que le decimos que ejecute es <tt class="docutils literal">self.action</tt>, que definimos ahí
mismo en el ejemplo.</p>
<p>Este método no tiene demasiadas restricciones, pero hay que prestar atención
a los parámetros declarados, porque dependen de cada evento.  Para el evento
con el que estamos trabajando, el método recibirá el usuario que nos dijo
algo, el canal en el que se dijo, y el mensaje en cuestión.</p>
<p>Luego de calcular el resultado que buscamos (la suma de los números pasados,
calculado de forma simple para no complicar el ejemplo), contestamos al
usuario utilizando otro método heredado: <tt class="docutils literal">self.say</tt>.  Al mismo le
pasamos primero el destino de lo que estamos diciendo (en este caso el
canal por dónde nos hablaron), luego el mensaje que queremos decir, y
finalmente valores para reemplazar en ese mensaje (veremos luego por qué
es importante no reemplazarlos directamente).</p>
<p>Las siguientes lineas muestran el diálogo con el bot (que llamamos
<em>examplia</em>) en la vida real:</p>
<pre class="literal-block">
&lt;usuario&gt;   examplia, 12 88
&lt;examplia&gt;  usuario, la suma es 100
&lt;usuario&gt;   examplia, 4 5 6
&lt;examplia&gt;  usuario, la suma es 15
</pre>
<div class="section" id="pero-como-pruebo-eso">
<h2>¿Pero cómo pruebo eso?</h2>
<p>Para probar Lalita no hace falta realizar ninguna instalación en particular.
Se puede bajar y descomprimir un tarball, o incluso bajar todo el proyecto
entero haciendo <tt class="docutils literal">bzr branch lp:lalita</tt>, y usarlo directamente.</p>
<p><em>FIXME: también se puede instalar con easy_install, mostrar cómo, ver si
tenemos que cambiar algo del texto porque instalado así se usa distinto.</em></p>
<p><em>FIXME: re-redactar esto! tenemos que arrancar con los tres pasos para
hacerlo funcionar, y luego explicamos qué es cada cosa, de manera que le
sirva también a aquellos que no quieren leer.  Para hacerla más fácil
daremos un ejemplo que se conecte a freenode.</em></p>
<p>Entrando al directorio donde está el proyecto, hay tres archivos que tenemos
que considerar para probar el ejemplo.</p>
<ul class="simple">
<li>El código arriba mostrado grabado en un archivo en el directorio
<tt class="docutils literal">plugins/</tt>; en nuestro caso lo guardaremos en un archivo llamado
<tt class="docutils literal">plugins/ejemplodoc.py</tt>.</li>
<li>El programa principal, que es <tt class="docutils literal">ircbot.py</tt>, y que mostraremos abajo
cómo ejecutar.</li>
<li>Un archivo de configuración, <tt class="docutils literal">config.py</tt>.  El proyecto trae un
<tt class="docutils literal">config.py.example</tt> con múltiples configuraciones de muestra, pero
veremos aquí mismo cómo hacer uno básico que nos sirva para probar
el ejemplo.</li>
</ul>
<p>La configuración no es más que un diccionario Python con toda la información
necesaria.  Aquí mostramos una configuración muy sencilla. Pueden ver
el <tt class="docutils literal">config.py.example</tt> para otras configuraciones, y abajo en este
mismo documento para más explicaciones.</p>
<p>En nuestro caso usaremos:</p>
<pre class="literal-block">
servers = {
   'example': dict(
       encoding = 'utf8',
       host = 'localhost', port = 6667,
       nickname = 'examplia',
       channels = {
           '#humites': {},
       },
       plugins = {
           'ejemplodoc.Sum': {},
       },
   ),
}
</pre>
<p>En este caso tenemos un sólo server configurado, llamado <tt class="docutils literal">example</tt>,
apuntando a localhost en el puerto 6667 (lo más fácil para probar ejemplos
y desarrollar nuestro propio plugin es instalar un servidor de IRC en la
propia computadora. Por ejemplo, se puede utilizar <tt class="docutils literal"><span class="pre">dancer-ircd</span></tt>,
principalmente porque al instalarlo ya queda funcionando como queremos y
no hay que realizar configuraciones adicionales).</p>
<p>En la configuración decimos que el nick del bot será <tt class="docutils literal">examplia</tt>, y
utilizará UTF-8 como encoding, y nos conectaremos al canal <tt class="docutils literal">#humites</tt>,
instanciando al plugin que acabamos de crear (notar que la forma de
especificar al plugin es <tt class="docutils literal">archivo.Clase</tt> (sin el <tt class="docutils literal">.py</tt>), lo que nos da la
libertad de tener varios plugins en distintos archivos y sólo especificar
el que queremos usar.</p>
<p>Una vez grabado el config.py, probamos todo haciendo:</p>
<pre class="literal-block">
python ircbot.py example
</pre>
<p>Usamos <tt class="docutils literal">python</tt> para llamar al intérprete, <tt class="docutils literal">ircbot.py</tt> para ejecutar
Lalita, y <tt class="docutils literal">example</tt> para indicarle cual de los servidores configurados
vamos a utilizar (podemos tener muchos configurados y usar algunos
solamente).  Se muestra solamente la forma de ejecución más simple, ver
abajo distintas opciones que se pueden utilizar en cada caso.</p>
</div>
</div>
<div class="section" id="usando-ordenes">
<h1>Usando ordenes</h1>
<p>Normalmente, para la funcionalidad del ejemplo anterior, se hubiese usado una
orden (o <em>comando</em>).</p>
<p>Usar ordenes nos permite ejecutar determinadas funcionalidades del bot sin
tener que hablarle directamente.  Los comandos se identifican porque comienzan
con un <tt class="docutils literal">&#64;</tt> al principio; entonces, lo que buscamos es poder hacer lo
siguiente:</p>
<pre class="literal-block">
&lt;usuario&gt;   &#64;sumar 12 88
&lt;examplia&gt;  usuario, la suma es 100
&lt;usuario&gt;   &#64;sumar 4 5 6
&lt;examplia&gt;  usuario, la suma es 15
</pre>
<p>Vemos que no le hablamos al bot directamente, sino que usamos el comando
<tt class="docutils literal">contar</tt>.  Modificamos ligeramente nuestro código anterior para poder
implementar esta orden:</p>
<pre class="literal-block">
# -*- coding: utf8 -*-

from lalita import Plugin

class Sum(Plugin):
    &quot;&quot;&quot;Ejemplo que suma los nros pasados.&quot;&quot;&quot;

    def init(self, config):
        self.register(self.events.COMMAND, self.action, (&quot;sumar&quot;,))

    def action(self, user, channel, command, *args):
        u&quot;Suma los números recibidos.&quot;
        result = sum(int(x) for x in args)
        self.say(channel, u&quot;%s, la suma es %d&quot;, user, result)
</pre>
<p>Vemos que cambió la linea de registración.  Ahora nos registramos a otro
evento, y además pasamos más datos: una tupla con los comandos a registrar
(<tt class="docutils literal">sumar</tt>, que es lo que usamos arriba con el <tt class="docutils literal">&#64;</tt>).</p>
<p>También cambió la signatura de la función, ahora se recibe el usuario y
el canal (como antes), más el comando con el que llegamos ahí, más todos
los parámetros pasados al comando (notar que la forma de calcular el
resultado varía ligeramente, ya que la info la recibimos preprocesada
en este caso).</p>
<div class="section" id="multiples-comandos-para-una-misma-funcionalidad">
<h2>Múltiples comandos para una misma funcionalidad</h2>
<p>Es normal la necesidad de proveer la misma funcionalidad para distintos
comandos.  Esto viene de la necesidad de soportar el comando en dos idiomas,
o para compatibilidad con formas viejas de escribirlo.</p>
<p>Lalita está preparada para soportar esto de forma sencilla, ya que a la hora
de registrar un método podemos hacerlo para distintos comandos.  Veamos esto
en funcionamiento; modifiquemos la linea de registración del ejemplo anterior
para que diga:</p>
<pre class="literal-block">
self.register(self.events.COMMAND, self.action,
              (&quot;suma&quot;, &quot;sumar&quot;, &quot;sum&quot;))
</pre>
<p>Entonces, podemos usar cualquiera de esos comandos:</p>
<pre class="literal-block">
&lt;usuario&gt;   &#64;sumar 12 3
&lt;examplia&gt;  usuario, la suma es 15
&lt;usuario&gt;   &#64;suma 12 3
&lt;examplia&gt;  usuario, la suma es 15
&lt;usuario&gt;   &#64;sum 12 3
&lt;examplia&gt;  usuario, la suma es 15
</pre>
</div>
<div class="section" id="ordenes-genericas-del-bot">
<h2>Ordenes genéricas del bot</h2>
<p>Lalita tiene sus propios metacomandos que nos permite acceder a funcionalidad
que va más allá de los plugins instalados.</p>
<p>Las ordenes intrínsecas a Lalita misma son <tt class="docutils literal">help</tt>, <tt class="docutils literal">list</tt> y <tt class="docutils literal">more</tt>.</p>
<p>El primero nos da un mensaje genérico, o la ayuda específica de un
determinado comando.  El segundo nos lista todos los comandos disponibles.
Vemos una ejemplo de uso de estos en las siguientes lineas:</p>
<pre class="literal-block">
&lt;usuario&gt;   &#64;help
&lt;examplia&gt;  &quot;list&quot; para ver las ordenes; &quot;help cmd&quot; para cada uno
&lt;usuario&gt;   &#64;list
&lt;examplia&gt;  Las ordenes son: ['help', 'list', 'more', 'sum', 'suma', 'sumar']
&lt;usuario&gt;   &#64;help sumar
&lt;examplia&gt;  Suma los números recibidos.
</pre>
<p>En la lista de ordenes vemos que tenemos los metacomandos más todos los
comandos que nosotros registramos (incluso si apuntan al mismo método dentro
de nuestro código).  ¿Pero de dónde viene la ayuda que Lalita muestra para
nuestros comandos?  Si prestaron la suficiente atención verán que para
esto se utiliza el docstring del método implementado.</p>
<p>Si prestaron atención, también habrán notado que nombré tres metacomandos
arriba, pero expliqué solamente dos.  Nos queda el tercero: <tt class="docutils literal">more</tt>.  Esta
es una orden utilizada sólo en casos muy específicos: cuando entra en acción
una regulación de Lalita para comportarse decentemente en un canal.</p>
<p>Veremos luego que hay formas de contestar más de una linea en una orden,
lo cual es muy útil si uno quiere implementar funciones de búsquedas, por
ejemplo.  ¿Pero qué pasaría si el plugin contesta con muchos resultados,
digamos... 1000?  Lo normal es que el servidor de IRC nos eche por
<em>flood</em> (ya que inundaríamos a todos los usuarios con un sin fin de
lineas; esta protección está implementada en la mayoría de los
servidores).  Entonces Lalita tiene un mecanismo para que el plugin no
pueda caer en este error.</p>
<p>Si el plugin contesta muchas lineas al mismo canal o usuario, sólo pasan
las primeras 5 y el resto se encola y no se muestran a menos que el mismo
usuario que generó el comando original diga <tt class="docutils literal">&#64;more</tt>, haciendo que Lalita
muestre las próximas 5 lineas encoladas, y así hasta que se acabe lo
encolado, el usuario diga otra cosa, o pase un determinado tiempo que hace
caducar a la cola de respuestas.</p>
<p><em>FIXME: indicar cómo se configura ese &quot;5&quot; para que no sea mágico.</em></p>
</div>
</div>
<div class="section" id="cuales-son-los-eventos-que-podemos-recibir">
<h1>¿Cuales son los eventos que podemos recibir?</h1>
<p>Los plugins pueden recibir muchos eventos. La siguiente lista los agrupa por
el tipo de suceso que el evento informa, mostrando los parámetros que se
envían en cada caso y una pequeña descripción de qué significa.</p>
<p>Eventos referentes a la conexión del bot contra el server:</p>
<ul class="simple">
<li><tt class="docutils literal">CONNECTION_MADE []</tt>: La conexión está establecida contra el servidor.</li>
<li><tt class="docutils literal">CONNECTION_LOST []</tt>: La conexión se terminó.</li>
<li><tt class="docutils literal">SIGNED_ON []</tt>: Ya se identificó correctamente con el server.</li>
<li><tt class="docutils literal">JOINED [canal]</tt>: El plugin ya se unió al canal indicado.</li>
</ul>
<p>Eventos que indican personas hablando:</p>
<ul class="simple">
<li><tt class="docutils literal">PRIVATE_MESSAGE [usuario, mensaje]</tt>: Algo dicho a Lalita por privado (no
en un canal público).</li>
<li><tt class="docutils literal">TALKED_TO_ME [usuario, canal, mensaje]</tt>: Algo dicho en el canal, pero
específicamente a Lalita.</li>
<li><tt class="docutils literal">PUBLIC_MESSAGE [usuario, canal, mensaje]</tt>: Algo dicho en el canal, de
forma genérica.</li>
<li><tt class="docutils literal">COMMAND [usuario, canal, comando, parámetros]</tt>: Un comando generado en el
canal, especificando el comando y los argumentos al mismo.</li>
</ul>
<p>Eventos que representan acciones de los usuarios o hacia los usuarios.</p>
<ul class="simple">
<li><tt class="docutils literal">ACTION [usuario, canal, mensaje]</tt>: El usuario generó una acción en el
canal (por ejemplo, &quot;/me&quot;).</li>
<li><tt class="docutils literal">JOIN [usuario, canal]</tt>: El usuario se sumó al canal en cuestión.</li>
<li><tt class="docutils literal">LEFT [usuario, canal</tt>: El usuario abandonó el canal en cuestión.</li>
<li><tt class="docutils literal">QUIT [usuario, mensaje]</tt>: El usuario se desconectó del servidor
completamente, indicando un determinado mensaje de salida.</li>
<li><tt class="docutils literal">KICK [pateado, canal, pateador, mensaje]</tt>: El usuario fue pateado del
canal, por una determinado operador (&quot;pateador&quot;), con un determinado mensaje.</li>
</ul>
</div>
<div class="section" id="registrando-eventos">
<h1>Registrando eventos</h1>
<p>Ya vimos el mecanismo básico para que un plugin registre métodos para que
sean llamados ante determinados eventos.  Aquí mostraremos todas las
combinaciones posibles que podemos lograr.</p>
<p>Como decíamos, el mecanismo básico de registración es:</p>
<pre class="literal-block">
self.register(&lt;evento&gt;, &lt;método&gt;)
</pre>
<p>La mayoría de los eventos permiten solamente eso.  Pero en algunos casos
podemos especificar otros parámetros.</p>
<p><em>FIXME: explicar qué sucede si te registrás dos veces.</em></p>
<div class="section" id="multiples-comandos">
<h2>Múltiples comandos</h2>
<p>En el caso del evento COMMAND, se debe especificar una tupla con todos los
nombres de comandos u ordenes que se registrarán para el método en cuestión.
Esto nos permite especificar varios comandos para un determinado método, y
varios métodos para determinados comandos, como se muestra en las
siguientes lineas:</p>
<pre class="literal-block">
self.register(self.events.COMMAND, self.sum, (&quot;sumar&quot;, &quot;sum&quot;))
self.register(self.events.COMMAND, self.multiply, (&quot;mult&quot;, &quot;multiply&quot;))
self.register(self.events.COMMAND, self.divide, (&quot;div&quot;,))
</pre>
<p><em>FIXME: no hay ejemplo para &quot;varios métodos para un determinado comando&quot;.</em></p>
</div>
<div class="section" id="filtrando-los-mensajes">
<h2>Filtrando los mensajes</h2>
<p>En el caso de los eventos <tt class="docutils literal">TALKED_TO_ME</tt>, <tt class="docutils literal">PRIVATE_MESSAGE</tt>,
y <tt class="docutils literal">PUBLIC_MESSAGE</tt>, se le puede especificar una expresión regular
para que Lalita filtre la cantidad de mensajes que generan este
tipo de evento.  De esta manera, nuestro plugin no recibiría todos los
mensajes de este tipo (que potencialmente podrían ser muchos, ya
que <tt class="docutils literal">PUBLIC_MESSAGE</tt> implica todo el tráfico del canal), sino
solamente aquellos ya filtrados.</p>
<p>Un ejemplo de esto sería la siguiente registración:</p>
<pre class="literal-block">
regex = re.compile(&quot;.*http://.*&quot;)
self.register(self.events.PUBLIC_MESSAGE, self.action, regex)
</pre>
<p>Entonces nuestro método <tt class="docutils literal">self.action</tt> no recibiría todos los mensajes
públicos, sólo aquellos que tengan <tt class="docutils literal"><span class="pre">http://</span></tt> en el mensaje.</p>
<p>Prestar atención que no se pasa la cadena directamente, sino una expresión
regular compilada.  Esto es por flexibilidad: realmente podríamos pasar
no solamente una expresión regular, sino que tenemos la posibilidad de
pasar cualquier objeto que preparemos que tenga el método <tt class="docutils literal">.match()</tt>
(si devuelve algo que evalúa a <tt class="docutils literal">True</tt>, se pasa el mensaje al plugin,
sino no).</p>
</div>
<div class="section" id="comandos-automaticos">
<h2>Comandos automáticos</h2>
<p>Es más sencillo y directo para los usuarios del bot, en algunos casos, el
poder especificar el comando hablando directamente con el bot, ya sea de
forma privada o pública (y no solamente usando el <tt class="docutils literal">&#64;</tt> al principio).</p>
<p>Por ejemplo, si nosotros tenemos registrado el comando <tt class="docutils literal">sumar</tt>, como en
el ejemplo anterior, podríamos tener el siguiente diálogo:</p>
<pre class="literal-block">
&lt;usuario&gt;   &#64;sumar 12 3
&lt;examplia&gt;  usuario, la suma es 15
&lt;usuario&gt;   examplia, sumar 12 3
&lt;examplia&gt;  usuario, la suma es 15
</pre>
<p>Esto lo podríamos hacer a mano (recibiendo todos los eventos públicos y
privados y filtrando), pero Lalita ya nos ofrece esta funcionalidad integrada.</p>
<p>Para activarla, sólo tenemos que hacer:</p>
<pre class="literal-block">
self.set_options(automatic_command=True)
</pre>
<p><em>FIXME: no vamos a tener set_options, todas las opciones serán manejadas
desde la config.</em></p>
<p>De esta manera, todos los eventos <tt class="docutils literal">TALKED_TO_ME</tt> y <tt class="docutils literal">PRIVATE_MESSAGE</tt>
que tengan un mensaje que comiencen con un comando registrado, serán
modificados y enviados al plugin como si hubiese sido justamente una
orden, y no un evento de esos tipos.</p>
</div>
</div>
<div class="section" id="hablando-con-mas-libertad">
<h1>Hablando con más libertad</h1>
<p>En un capítulo anterior mostramos el uso básico de <tt class="docutils literal">self.say</tt>, que es la
herramienta que tienen los plugins para decir cosas a los usuarios.</p>
<p>La sintaxis de esta herramienta es sencilla:</p>
<pre class="literal-block">
self.say(&lt;destino&gt;, &lt;texto&gt;, [&lt;arg1&gt;, ...])
</pre>
<p>El destino es a quien va dirigido el mensaje.  Si es un usuario, el mensaje
será privado.  Si es un canal (que empieza por <tt class="docutils literal">#</tt>), el mensaje será dicho
en el canal público (aquí Lalita aplica una restricción: el plugin solo
puede contestar algo por el mismo canal que se le preguntó o en
privado, pero no puede cruzar respuestas de canales).</p>
<p>El segundo parámetro es el texto del mensaje que queremos comunicar.  No hay
a priori una restricción de longitud, pero los textos muy largos se
transforman a varias lineas, por restricciones propias de IRC.  Se
recomienda que el texto sea siempre una cadena Unicode, incluso si en
el mensaje no estamos utilizando caracteres no ASCII.</p>
<p>Si queremos componer el mensaje con algunos parámetros (como el nombre
del usuario o el resultado de la suma en el ejemplo anterior), NO debemos
hacer el reemplazo directamente, sino armar la cadena como corresponde y
pasar los argumentos luego del texto.</p>
<p>En otras palabras, y siguiendo con el ejemplo anterior, se recomienda NO
hacer lo siguiente:</p>
<pre class="literal-block">
self.say(channel, u&quot;%s, la suma es %d&quot; % (user, result))
</pre>
<p>Se debe hacerlo de esta manera:</p>
<pre class="literal-block">
self.say(channel, u&quot;%s, la suma es %d&quot;, user, result)
</pre>
<p>Hay dos razones para esto.  La primera es que en caso de tener una cantidad
incorrecta de parámetros o tipos de datos incorrectos en la conversión,
esto se puede manejar mejor por Lalita.  La segunda y más importante es que
al no reemplazar los valores, podemos hacer que nuestros textos sean
internacionalizables (ver abajo más detalle sobre esto).</p>
<div class="section" id="siendo-verborragicos">
<h2>Siendo verborrágicos</h2>
<p>No hay ninguna restricción sobre la cantidad de lineas que puede contestar
un plugin (más allá del mecanismo de encolado de mensajes para evitar
<em>flood</em> que se describió arriba).</p>
<p>Es decir, un plugin puede contestar dos o más lineas, usando varias veces
el <tt class="docutils literal">self.say</tt>, por ejemplo:</p>
<pre class="literal-block">
self.say(channel, u&quot;El resultado es %d&quot;, result)
self.say(channel, u&quot;(tiempo de cálculo: %.2f segundos)&quot;, t)
</pre>
</div>
<div class="section" id="prometiendo-respuestas-a-futuro">
<h2>Prometiendo respuestas a futuro</h2>
<p>Los métodos de los plugins no deben tardar mucho. Esto se debe a que Lalita
está programada usando un motor de ejecución asincrónico llamado <a class="reference external" href="http://twistedmatrix.com/trac/">Twisted</a>,
por lo que las ejecuciones de los métodos no son interrumpibles.</p>
<p>En otras palabras, si un método de un plugin tarda mucho, Lalita no
puede atender el resto de las cosas que tiene que hacer (escuchar
múltiples canales, ejecutar métodos de otros plugins, etc.).</p>
<p>Entonces, ¿cómo hacemos si tenemos que acceder a servicios que
potencialmente pueden tardar mucho, como base de datos, o usar la red?
Aquí es donde entra en juego un mecanismo de Twisted llamado <a class="reference external" href="http://twistedmatrix.com/documents/current/core/howto/defer.html">Deferreds</a>.</p>
<p>Pueden buscar algo de documentación sobre Deferreds en ese enlace, y
revisar en el plugin de ejemplo (<tt class="docutils literal">plugins/example.py</tt>) cómo se
implementa esto, pero básicamente el proceso es: en lugar de hacer
<tt class="docutils literal">self.say()</tt> y contestar algo, la ejecución del método devuelve al
terminar una promesa a futuro.</p>
<p>Esta promesa a futuro es el <em>deferred</em>, que se consumirá cuando el
plugin esté listo para contestar.  Realmente el plugin puede devolver o
no el deferred, ya que el funcionamiento será el mismo, pero si al usar
un deferred el plugin lo devuelve, Lalita lo usará para loguear la
finalización exitosa o por error del mismo.</p>
</div>
<div class="section" id="hablando-sin-contestar">
<h2>Hablando sin contestar</h2>
<p><em>FIXME: quizás pongamos que el default es &quot;hablar libre&quot;, y que se puede
configurar para que te restrinja. Deberíamos re-redactar esto acá si fuese
así</em></p>
<p>Como mencionamos antes, hay una regla básica que Lalita fuerza para todos
los plugins: estos mismos sólo pueden contestar por el canal que se les
habló (o a la persona en privado que originó el diálogo).  Esta es una
regla de seguridad, que ha probado ser útil, pero al mismo tiempo
restringe algunos comportamientos que desearíamos para un plugin
específico (como poder decirle a un plugin que avise algo importante en
todos los canales en donde está Lalita).</p>
<p>Un efecto secundario de esta limitación es que Lalita no puede decir algo
sin que le hablen primero, y también hay casos de uso en lo que esto sería
deseable, como tener un plugin que informe de noticias nuevas que reciba
por RSS, por ejemplo.</p>
<p>Si necesitamos cualquiera de estas dos funcionalidades, debemos desactivar esta
restricción, de la siguiente manera:</p>
<pre class="literal-block">
self.set_options(free_talk=True)
</pre>
<p><em>FIXME: no vamos a tener set_options, todas las opciones serán manejadas
desde la config.</em></p>
<p>Luego de esa configuración, podremos generar los mensajes que deseemos
desde el plugin, a cualquier destino, y sin importar si nos hablaron
primero o no.</p>
</div>
</div>
<div class="section" id="armando-un-plugin-mas-profesional">
<h1>Armando un plugin más profesional</h1>
<p>Más allá de que armar un plugin sea sencillo, implementar una determinada
funcionalidad de manera robusta y preparada para distribuir en varios
idiomas, o dejarla corriendo 7x24 como servicio confiable, implica
tener algunas precauciones y utilizar algunos mecanismos para hacer
de nuestro programa algo más profesional.</p>
<div class="section" id="logueando">
<h2>Logueando</h2>
<p>Una herramienta que nos ofrece Lalita es la de poder loguear información
(que irá a disco o pantalla en función de configuraciones más generales,
ver abajo).  Para esto tenemos en nuestros plugins a <tt class="docutils literal">self.logger</tt>,
al que podemos usar con distintos grados de severidad, ejemplo:</p>
<pre class="literal-block">
self.logger.debug(&quot;Recibimos un mensaje de %s&quot;, user)
self.logger.error(&quot;Error interno al procesar el pedido&quot;)
</pre>
<p>Los distintos niveles a los que tenemos acceso son <tt class="docutils literal">debug</tt>, <tt class="docutils literal">info</tt>,
<tt class="docutils literal">warning</tt>, <tt class="docutils literal">error</tt> y <tt class="docutils literal">critical</tt>.  Estos niveles son los clásicos
del <a class="reference external" href="http://docs.python.org/dev/library/logging.html#logging-levels">módulo logging de Python</a>.</p>
</div>
<div class="section" id="documentando-nuestros-metodos">
<h2>Documentando nuestros métodos</h2>
<p>Los docstrings de los métodos de nuestros plugins, que nosotros utilizamos
para implementar funcionalidad, son interpretados automáticamente por
Lalita como la documentación de ayuda para ofrecer al usuario.</p>
<p>Si nos fijamos en nuestro ejemplo anterior, nosotros teníamos nuestro
método que sumaba los números que le pasábamos al bot a través del
comando <tt class="docutils literal">sumar</tt>:</p>
<pre class="literal-block">
def action(self, user, channel, command, *args):
    u&quot;Suma los números recibidos.&quot;
    ...
</pre>
<p>El usuario, entonces, puede hacer...:</p>
<pre class="literal-block">
&lt;usuario&gt;   &#64;help sumar
&lt;examplia&gt;  Suma los números recibidos.
</pre>
<p>...y recibir directamente la documentación que escribimos.</p>
<p>Se recomienda que estos docstrings sean cadenas Unicode.  También,
estos docstrings son internacionalizables de la manera que
explicamos a continuación.</p>
</div>
<div class="section" id="internacionalizando-nuestros-textos">
<h2>Internacionalizando nuestros textos</h2>
<p>Lalita tiene un mecanismo de internacionalización que difiere del estándar
seguido por todos los programas.  Esto es debido a que de la forma estándar
la ejecución del programa seguiría un lenguaje determinado, mientras que
Lalita puede estar hablando un idioma en un canal, y otro idioma en otro
canal o servidor.</p>
<p>En nuestro caso, el plugin debe proveer una tabla de traducción,
registrándola de la siguiente manera:</p>
<pre class="literal-block">
self.register_translation(self, TABLA_TRADUCCION)
</pre>
<p>Esta tabla de traducción es sencillamente un diccionario de Python
con la siguiente estructura:</p>
<pre class="literal-block">
{ &lt;cadena original 1&gt;: { &lt;idioma1&gt; : &lt;cadena 1 en idioma 1&gt;,
                         &lt;idioma2&gt; : &lt;cadena 1 en idioma 2&gt;,
                         ...
                       },
  &lt;cadena original 2&gt;: { &lt;idioma1&gt; : &lt;cadena 2 en idioma 1&gt;,
                         &lt;idioma2&gt; : &lt;cadena 2 en idioma 2&gt;,
                         ...
                       },
  ...
}
</pre>
<p>Notar como no es obligatorio escribir las cadenas originales en nuestro
código en ningún idioma en particular, sólo tenemos que proveer las
traducciones a otros idiomas que nos interese en la tabla de traducciones.</p>
<p>Los distintos idiomas 1, 2, etc. mostrados arriba son &quot;en&quot;, &quot;it&quot;, etc.,
siguiendo las dos letras estándar.  Estas dos letras se utilizan en la
configuración de los canales para que Lalita sepa qué idioma se habla en
cada canal de cada servidor al que se conecte, de manera que ella y
sus plugins hablen ese idioma en cuestión.</p>
<p>Se puede ver una implementación real de esto en el plugin de
ejemplo <tt class="docutils literal">plugins/example.py</tt>.</p>
</div>
<div class="section" id="configurando-el-plugin">
<h2>Configurando el plugin</h2>
<p>Si prestamos atención al <tt class="docutils literal">config.py</tt> de ejemplo que utilizamos arriba,
veremos que indicamos que se use el plugin de suma que habíamos escrito:</p>
<pre class="literal-block">
plugins = {
    'ejemplodoc.Sum': {},
},
</pre>
<p>El diccionario que aquí pasamos vacío puede tener una configuración
totalmente libre, y será pasado por Lalita al plugin en tiempo de
inicialización: el parámetro <tt class="docutils literal">config</tt> del <tt class="docutils literal">__init__</tt> es justamente
eso, y nos permite configurar el plugin desde el archivo, sin tener
que implementar mecanismos alternativos.</p>
</div>
</div>
<div class="section" id="algunos-plugins-que-vienen-integrados">
<h1>Algunos plugins que vienen integrados</h1>
<p>Lalita viene con algunos plugins que implementan funcionalidades
básicas útiles para muchos canales de IRC.</p>
<p>La idea de hacerlos formar parte del proyecto es que si se necesita la
misma funcionalidad o una parecida, no se tenga que arrancar desde cero.
De la misma manera, también pueden servir como ejemplos para ver cómo
realizar determinadas tareas.  Dicho esto, cabe aclarar que la calidad
de los plugins varía un poco: algunos respetan PEP 8 y tienen casos
de prueba en el directorio <tt class="docutils literal">plugins/tests/</tt>, mientras que otros
ni siquiera tienen docstrings...</p>
<ul class="simple">
<li>example.py: Plugin de ejemplo; no provee ninguna funcionalidad
específica o útil, pero es un buen ejemplo para ver y copiar.</li>
<li>freenode.py: Realiza todo el diálogo de autenticación contra los
servidores de Freenode (debemos configurar algunos parámetros de
forma adecuada, ver el archivo <tt class="docutils literal">config.py.example</tt>).  Este plugin
no ofrece ninguna funcionalidad al usuario final, pero nos permite
conectarnos a estos servidores sin realizar la autenticación nosotros.</li>
<li>misc.py: Plugin que implementa una funcionalidad muy sencilla: contesta
&quot;pong&quot; al usuario cuando este le dice &quot;ping&quot; a Lalita.</li>
<li>seen.py: Implementa dos funcionalidades interesantes: &quot;last&quot; y &quot;seen&quot;.
El primero indica qué fué lo último que dijo un determinado usuario, y
el segundo nos contesta cuando fue la última vez que el usuario fue
visto (a veces esto coincide, a veces no).</li>
<li>url.py: Va juntando todas las URLs que se van mencionando en los
distintos canales, y luego nos permite buscar en las mismas.</li>
</ul>
</div>
<div class="section" id="configuracion-avanzada">
<h1>Configuración avanzada</h1>
<p>El archivo de configuración de Lalita tiene muchas opciones y es bastante
flexible, así que más allá de inspeccionar el <tt class="docutils literal">config.py.example</tt> es
interesante una descripción de sus capacidades.  También, al momento de
ejecutar <tt class="docutils literal">ircbot.py</tt> podemos hacer uso de otras opciones, que se
explican en esta sección.</p>
<div class="section" id="el-archivo-de-config">
<h2>El archivo de config</h2>
<p>La estructura del <tt class="docutils literal">config.py</tt> necesario para que Lalita funcione es
básicamente un gran diccionario de Python.</p>
<p>Las claves de este gran diccionario son los distintos servidores
configurados, los que se especificarán al ejecutar Lalita.  Cada uno de
estos servidores tiene una configuración que también es un diccionario.</p>
<p>El diccionario de cada servidor puede tener las siguientes claves:</p>
<blockquote>
<ul class="simple">
<li>encoding: La codificación de Unicode que se hablará contra ese servidor
(&quot;utf8&quot;, &quot;latin1&quot;, etc.).</li>
<li>host: La dirección IP o el nombre del server.</li>
<li>port: El puerto del servidor contra el que conectarse.</li>
<li>nickname: El nick que tendrá nuestro bot.</li>
<li>channels: Los canales a los que entrar en el servidor, más la respectiva
configuración (ver abajo).</li>
<li>plugins: Los plugins (junto con posible configuración) que se ejecutarán a
nivel de servidor (ver abajo).</li>
<li>ssl: En True si debemos usar SSL para conectarnos contra el servidor.</li>
<li>password: Una posible palabra clave para el servidor.</li>
<li>plugins_dir: El directorio del cual levantar los plugins (si no se
especifica se toman del directorio <tt class="docutils literal">plugins/</tt> del proyecto.</li>
</ul>
</blockquote>
<p>El valor de la clave <em>channels</em> arriba es un diccionario, donde las claves
son los distintos canales, y el valor correspondiente para cada clave es
la configuración de ese canal, que puede tener dos claves: <tt class="docutils literal">plugins</tt>,
con los distintos plugins habilitados para ese canal (junto con su
diccionario de configuración), y <tt class="docutils literal">encoding</tt>, con la codificación del
canal (si fuese distinta que la del servidor en general).</p>
<p>Podemos notar que los plugins pueden estar descriptos tanto a nivel de
servidor como a nivel de canal.  Ambos casos son útiles y no hay a priori
una regla que indique en donde configurar un determinado plugin.  En
general, ubicaremos un plugin a nivel de canal si es algo específico
para un canal y no queremos que esté disponible para todos; y ubicaremos
un plugin a nivel de servidor cuando es necesario para conectarse
(como el que mencionamos de <em>freenode</em>), o lo queremos utilizar también
por privado (ya que cuando dialogamos en privado con un bot estamos
afuera de todo canal).</p>
<p>Por último, cabe notar que es muy difíicil ejemplificar las distintas
combinaciones aquí, pero siempre está el tan mencionado
<tt class="docutils literal">config.py.example</tt> para revisar y tomar de ejemplo.</p>
</div>
<div class="section" id="parametros-de-linea-de-comando">
<h2>Parámetros de linea de comando</h2>
<p>Cuando ejecutamos a Lalita a través del archivo <tt class="docutils literal">ircbot.py</tt> tenemos varios
parámetros que nos permiten controlar algunas configuraciones.</p>
<p>La sintaxis general es:</p>
<pre class="literal-block">
ircbot.py [-t][-a][-o output_loglvl][-p plugins_loglvl]
          [-f fileloglvl][-n logfname] [server1, [...]]
</pre>
<p>El argumento <em>-t</em> (o <em>--test</em>) sirve para realizar pruebas solamente: ejecuta
dos plugins que se conectan a un mismo canal y charlan entre ellos.  Usaremos
esta opción en desarrollo, y no en producción, así que en general la
podemos obviar.</p>
<p>Si pasamos el argumento <em>-a</em> (o <em>--all</em>), se utilizarán todos los
servidores especificados en <tt class="docutils literal">config.py</tt>, y no se tendrán en cuenta aquellos
indicados en los parámetros de ejecución; por otro lado, si no utilizamos
<em>-a</em> tenemos que especificar cual o cuales servidores debe tomar de
la configuración para ejecutarse.</p>
<p>Los argumentos <em>-o</em> (<em>--output-log-level</em>), <em>-p</em> (<em>--plugin-log-level</em>)
y <em>-f</em> (<em>--file-log-level</em>) controlan distintos niveles de logueo, para la
salida en standard output, para filtrar lo recibido de los plugins, y
para escribir en el archivo de log, respectivamente.</p>
<p>El nivel de logueo por default es INFO (con lo que no mostrará todos los
mensajes de DEBUG, por ejemplo).  Podemos configurar cada caso en DEBUG para
ver todo, o en WARNING si solo queremos ver las advertencias y mensajes
más serios, o cualquier combinación que nos plazca.</p>
<p>Con <em>-n</em> (o <em>--log-filename</em>) especificamos en qué archivo queremos
que se loguee la información que va a un archivo.</p>
</div>
</div>
</div>
</body>
</html>
